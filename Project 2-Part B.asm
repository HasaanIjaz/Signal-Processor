START:
;INITIALIZE MEMORY
MOV R0, #40H
MOV B,#10
AGAIN:
MOV @R0, #0H
INC R0
DJNZ B, AGAIN

;PUT ADC VALUES IN MEMORY
MOV R0, #40H
MOV B,#10
REPEAT:
LCALL ADC; Get Value from ADC
MOV R7, #100
VALDELAY: DJNZ R7, VALDELAY
MOV @R0, A; 40H = MAX VALUE AT END
INC R0
DJNZ B, REPEAT

;CALCULATE DIFFERENCE AND PUT IN MEMORY
MOV B,#9
MOV R0, #40H
MOV R1, #41H
REPEAT2:
MOV A, @R1
CLR C
SUBB A, @R0
JNC NOCOMPLEMENT
CPL A
ADD A, #1
NOCOMPLEMENT:
MOV @R0, A
INC R0
INC R1
DJNZ B, REPEAT2

;CHECK IF SQUARE WAVE
MOV B, #9
MOV R0, #40H
REPEAT3:
MOV A, @R0
CJNE A, #0, DIFFNOT0
SJMP SQUARE
DIFFNOT0:
CJNE A, #140, DIFFNOT3V
DIFFNOT3V:
JC NOTSQUARE
SQUARE:
INC R0
DJNZ B, REPEAT3
LCALL CONFIGURE_LCD
LCALL DISPSQUARE
LCALL DELAY3
LJMP START

NOTSQUARE:
;CALCULATE DIFFERENCE OF DIFFERENCE
MOV B, #8
MOV R0, #40H
MOV R1, #41H
REPEAT4:
MOV A, @R1
CLR C
SUBB A, @R0
JNC NOCOMPLEMENT1
CPL A
ADD A, #1
NOCOMPLEMENT1:
MOV @R0, A
INC R0
INC R1
DJNZ B, REPEAT4

;CHECK IF TRAIANGULAR WAVE
MOV B, #8
MOV R0, #40H
REPEAT5:
MOV A, @R0
CJNE A, #1, DIFFDIFFNOT1
SJMP TRIANG
DIFFDIFFNOT1:
JNC SINE
TRIANG:
DJNZ B, REPEAT5
LCALL CONFIGURE_LCD
LCALL DISPTRIANGULAR
LCALL DELAY3
LJMP START

;THE WAVE IS SINE IF IT'S NEITHER SQUARE OR TRIANGULAR
SINE:
LCALL CONFIGURE_LCD
LCALL DISPSINE
LCALL DELAY3 
LJMP START

DELAY3:
MOV R0, #05H
DELAYSECOND: MOV R1, #0FFH
BACK2: MOV R2,#0FFH
HERE2: DJNZ R2,HERE2
DJNZ R1, BACK2
DJNZ R0,DELAYSECOND
RET

DISPSQUARE:
MOV A, #'S'
ACALL SEND_DATA
MOV A, #'Q'
ACALL SEND_DATA
MOV A, #'U'
ACALL SEND_DATA
MOV A, #'A'
ACALL SEND_DATA
MOV A, #'R'
ACALL SEND_DATA
MOV A, #'E'
ACALL SEND_DATA
RET

DISPTRIANGULAR:
MOV A, #'T'
ACALL SEND_DATA
MOV A, #'R'
ACALL SEND_DATA
MOV A, #'I'
ACALL SEND_DATA
MOV A, #'A'
ACALL SEND_DATA
MOV A, #'N'
ACALL SEND_DATA
MOV A, #'G'
ACALL SEND_DATA
MOV A, #'U'
ACALL SEND_DATA
MOV A, #'L'
ACALL SEND_DATA
MOV A, #'A'
ACALL SEND_DATA
MOV A, #'R'
ACALL SEND_DATA
RET

DISPSINE:
MOV A, #'S'
ACALL SEND_DATA
MOV A, #'I'
ACALL SEND_DATA
MOV A, #'N'
ACALL SEND_DATA
MOV A, #'E'
ACALL SEND_DATA
RET

ADC:
MOV P1,#0FFh
SETB P2.7
 CLR P2.6; CLR WRITE
NOP ;for 100 ns delay
SETB P2.6 ; low to high pulse TO WRITE
HERE: JB P2.7,HERE ; wait for end of conversion
CLR P2.5 ; make data appear at ADC pins
NOP
NOP ; for 200 ns delay
MOV A,P1 ; read converted data
SETB P2.5 ; prepare for next round
RET

CONFIGURE_LCD:	;THIS SUBROUTINE SENDS THE INITIALIZATION COMMANDS TO THE LCD
	mov a,#38H	;TWO LINES, 5X7 MATRIX
	acall SEND_COMMAND
	mov a,#0FH	;DISPLAY ON, CURSOR BLINKING
	acall SEND_COMMAND
	mov a,#06H	;INCREMENT CURSOR (SHIFT CURSOR TO RIGHT)
	acall SEND_COMMAND
	mov a,#01H	;CLEAR DISPLAY SCREEN
	acall SEND_COMMAND
	mov a,#80H	;FORCE CURSOR TO BEGINNING OF THE FIRST LINE
	acall SEND_COMMAND
	ret



SEND_COMMAND:
	mov p0,a		;THE COMMAND IS STORED IN A, SEND IT TO LCD
	clr p3.5		;RS=0 BEFORE SENDING COMMAND
	clr p3.6		;R/W=0 TO WRITE
	setb p3.7	;SEND A HIGH TO LOW SIGNAL TO ENABLE PIN
	acall DELAY
	clr p3.7
	ret


SEND_DATA:
	mov p0,a		;SEND THE DATA STORED IN A TO LCD
	setb p3.5	;RS=1 BEFORE SENDING DATA
	clr p3.6		;R/W=0 TO WRITE
	setb p3.7	;SEND A HIGH TO LOW SIGNAL TO ENABLE PIN
	acall DELAY
	clr p3.7
	ret

DELAY:
	push 0
	push 1
	mov r0,#50
DELAY_OUTER_LOOP:
	mov r1,#255
	djnz r1,$
	djnz r0,DELAY_OUTER_LOOP
	pop 1
	pop 0
	ret

